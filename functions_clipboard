# This file contains functions used for moving(cutting), copying and pasting files and directories from one folder to another
#
# GLOBAL VARIABLES
#
clipboardScriptDir=`pwd`;
# file which is used by functions to build and execute the paste command
# it also ensures the paste operations are persistent, they can also be performed if the system is rebooted
commandFile=$clipboardScriptDir/.pasteCommand;
#
function mvit {
    if [[ -z $1 ]]; then #if first script parameter is not set or has 0 characters
	operation='mv -i'; #write mv -i (move command, option -i for interactive - ask before overriding files) to variable $operation
    elif [[ $1 == "-o" ]]; then #if parameter "-o" (override) was entered
	operation='mv'; #write mv to variable $operation (move without interactive mode)
    else 
	echo 'Wrong command option. Please try again.';
	> "$commandFile"; #flush parameters file
	return 1; #error, end of script 
    fi 
    echo 'Enter keyword: '; #request search keyword from user
    read keyword;
    if [[ -z $keyword ]]; then #if no keyword entered 
	echo 'No input. Please try again';
	> "$commandFile"; #flush parameters file
	return 1; #error, end of script 
    fi
#
    echo $operation > "$commandFile"; #write the move command to the parameters file
    echo `pwd` >> "$commandFile"; #write the path of the current directory on the second line of the parameters file
    echo "$keyword" >> "$commandFile"; #write the keyword on the third line of the parameters file
    return 0; 
}

function cpit {
    if [[ -z $1 ]]; then #if first script parameter is not set or has 0 characters
	operation='cp -ir'; #write cp -ir (copy command, option -i for interactive - ask before overriding files, option -r for directories) to variable $operation
    elif [[ $1 == "-o" ]]; then #if parameter "-o" (override) was entered
	operation='cp -r'; #write cp -r to variable $operation (copy without interactive mode) 
    else 
	echo 'Wrong command option. Please try again.';
	> "$commandFile"; #flush parameters file
	return 1; #error, end of script 
    fi 
    echo 'Enter keyword: '; #request search keyword from user
    read keyword;
    if [[ -z $keyword ]]; then #if no keyword entered 
	echo 'No input. Please try again';
	> "$commandFile"; #flush parameters file
	return 1; #error, end of script 
    fi
#
    echo $operation > "$commandFile"; #write the copy command to the parameters file
    echo `pwd` >> "$commandFile"; #write the path of the current directory on the second line of the parameters file
    echo "$keyword" >> "$commandFile"; #write the keyword on the third line of the parameters file
    return 0; 
}

function psit {
    if [[ ! -f "$commandFile" ]]; then #if parameters file does not exist
	echo "Fatal error! Parameters file $commandFile does not exist.";
	return 1; #error, end of script
    fi 
    operation=`sed -n '1p' $commandFile`; #first line of the parameters file, type of operation (move/copy)
    source_dir=`sed -n '2p' $commandFile`; #second line of the parameters file, source directory (from which files/directories are moved/copied)
    dest_dir=`pwd`; #destination directory (where files are moved/copied; this is the current directory) 
    keyword=`sed -n '3p' $commandFile`; #third line of the parameters file (keyword)
    if [[ ! -z $1 ]]; then #if first script parameter exists 
	if [[ $1 == '-f' ]]; then # option -f (flush)
	    > "$commandFile"; #flush parameters file
	    echo 'Clipboard erased!';
	    return 0; #exit script, no action required anymore
	elif [[ $1 == '-d' ]]; then #option -d (display)
	    echo; 
	    cat "$commandFile"; #display parameters file contents
	    echo; 
	    return 0; #exit script, no action required anymore
	else 
	    echo 'Incorrect script option. Please try again'; 
	    return 1; #error, end of script
	fi
    fi 
    if [[ -z $operation ]]; then #if first row of the parameters file is empty (meaning no copy/move was initiated) 
	echo 'No move/copy command initiated. Clipboard empty.'; 
	return 1; #error, end of script
    elif [[ $operation == 'mv -i' ]] || [[ $operation == 'mv' ]]; then #if operation is move (interactive or not) 
	mvitems='yes'; #items will be moved
    elif [[ $operation == 'cp -ir' ]] || [[ $operation == 'cp -r' ]]; then #if operation is copy (interactive or not) 
	mvitems='no'; #items will be copied
    else
	echo "Incorrect entry in $commandFile, file will be flushed"; #error, no valid entry on the first row of the parameters file
	> "$commandFile"; #reset parameters file
	return 1; #end of script 
    fi
#
    if [[ ! -d "$source_dir" ]]; then #if the source directory does not exist (or is not a directory)
	echo "Invalid source directory $source_dir"; #error
	> "$commandFile"; #flush parameters file
	return 1; #end of script 
    fi
#
    if [[ -z $keyword ]]; then #if keyword is missing (third row of parameters file is empty) 
	echo 'No keyword found'; #error
	> "$commandFile"; #flush parameters file
	return 1; #end of script
    fi
#
    if [[ "$source_dir" == "$dest_dir" ]]; then #if source and destination directory match, an error will be displayed and the script will be aborted (parameters file will not be flushed, so user can apply paste.sh again when in another directory) 
	if [[ $mvitems == 'yes' ]]; then #error message for move operation
	    echo 'Cannot move. Source and destination directory are the same.'; 
	else #error message for copy operation
	    echo 'Cannot copy. Source and destination directory are the same.'; 
	fi
	return 1; #error, end of script
    fi 
#
    command="$operation $keyword $dest_dir"; #build the move/copy command 
    cd "$source_dir"; #cd to source directory ...
    eval "$command"; #execute the command 
    if [[ $? != 0 ]] || [[ $mvitems == 'yes' ]]; then #if command not successfully executed or if it was a move (not copy) operation
	> "$commandFile"; #parameters file is flushed (no sense to use it again if operation was unsuccessful; cannot use it to move items again as they can only be moved once from the source directory)
    fi
    cd - > /dev/null; #...and then back (to destination directory); dev/null for suppressing output
    return 0; 
}
